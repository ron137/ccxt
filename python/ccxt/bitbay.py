# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange

# -----------------------------------------------------------------------------

try:
    basestring  # Python 3
except NameError:
    basestring = str  # Python 2
import hashlib
import json
import time
import dateutil
import datetime
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import InvalidNonce


class bitbay (Exchange):

    def describe(self):
        return self.deep_extend(super(bitbay, self).describe(), {
            'id': 'bitbay',
            'name': 'BitBay',
            'countries': ['PL', 'EU'],  # Poland
            'rateLimit': 1000,
            'has': {
                'CORS': True,
                'withdraw': True,
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766132-978a7bd8-5ece-11e7-9540-bc96d1e9bbb8.jpg',
                'www': 'https://bitbay.net',
                'api': {
                    'public': 'https://bitbay.net/API/Public',
                    'private': 'https://bitbay.net/API/Trading/tradingApi.php',
                },
                'doc': [
                    'https://bitbay.net/public-api',
                    'https://bitbay.net/account/tab-api',
                    'https://github.com/BitBayNet/API',
                ],
                'fees': 'https://bitbay.net/en/fees',
            },
            'api': {
                'public': {
                    'get': [
                        '{id}/all',
                        '{id}/market',
                        '{id}/orderbook',
                        '{id}/ticker',
                        '{id}/trades',
                    ],
                },
                'private': {
                    'post': [
                        'info',
                        'trade',
                        'cancel',
                        'orderbook',
                        'orders',
                        'transfer',
                        'withdraw',
                        'history',
                        'transactions',
                    ],
                },
            },
            'markets': {
                'BTC/USD': {'id': 'BTCUSD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'baseId': 'BTC', 'quoteId': 'USD', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.00003}, 'cost': {'min':0.1} }},
                'BTC/EUR': {'id': 'BTCEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR', 'baseId': 'BTC', 'quoteId': 'EUR', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.00003}, 'cost': {'min':0.1} }},
                'BTC/PLN': {'id': 'BTCPLN', 'symbol': 'BTC/PLN', 'base': 'BTC', 'quote': 'PLN', 'baseId': 'BTC', 'quoteId': 'PLN', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.00003}, 'cost': {'min':0.1} }},
                'LTC/USD': {'id': 'LTCUSD', 'symbol': 'LTC/USD', 'base': 'LTC', 'quote': 'USD', 'baseId': 'LTC', 'quoteId': 'USD', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.0025}, 'cost': {'min':0.1} }},
                'LTC/EUR': {'id': 'LTCEUR', 'symbol': 'LTC/EUR', 'base': 'LTC', 'quote': 'EUR', 'baseId': 'LTC', 'quoteId': 'EUR', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.0025}, 'cost': {'min':0.1} }},
                'LTC/PLN': {'id': 'LTCPLN', 'symbol': 'LTC/PLN', 'base': 'LTC', 'quote': 'PLN', 'baseId': 'LTC', 'quoteId': 'PLN', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.0025} }, 'cost': {'min':0.1}},
                'LTC/BTC': {'id': 'LTCBTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'baseId': 'LTC', 'quoteId': 'BTC', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.0025}, 'cost': {'min':0.00003} }},
                'ETH/USD': {'id': 'ETHUSD', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD', 'baseId': 'ETH', 'quoteId': 'USD', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.00045}, 'cost': {'min':0.1} }},
                'ETH/EUR': {'id': 'ETHEUR', 'symbol': 'ETH/EUR', 'base': 'ETH', 'quote': 'EUR', 'baseId': 'ETH', 'quoteId': 'EUR', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.00045}, 'cost': {'min':0.1} }},
                'ETH/PLN': {'id': 'ETHPLN', 'symbol': 'ETH/PLN', 'base': 'ETH', 'quote': 'PLN', 'baseId': 'ETH', 'quoteId': 'PLN', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.00045}, 'cost': {'min':0.1} }},
                'ETH/BTC': {'id': 'ETHBTC', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'baseId': 'ETH', 'quoteId': 'BTC', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.00045}, 'cost': {'min':0.00003} }},
                'LSK/USD': {'id': 'LSKUSD', 'symbol': 'LSK/USD', 'base': 'LSK', 'quote': 'USD', 'baseId': 'LSK', 'quoteId': 'USD', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.025}, 'cost': {'min':0.1} }},
                'LSK/EUR': {'id': 'LSKEUR', 'symbol': 'LSK/EUR', 'base': 'LSK', 'quote': 'EUR', 'baseId': 'LSK', 'quoteId': 'EUR', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.025}, 'cost': {'min':0.1} }},
                'LSK/PLN': {'id': 'LSKPLN', 'symbol': 'LSK/PLN', 'base': 'LSK', 'quote': 'PLN', 'baseId': 'LSK', 'quoteId': 'PLN', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.025}, 'cost': {'min':0.1} }},
                'LSK/BTC': {'id': 'LSKBTC', 'symbol': 'LSK/BTC', 'base': 'LSK', 'quote': 'BTC', 'baseId': 'LSK', 'quoteId': 'BTC', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.025}, 'cost': {'min':0.00003} }},
                'BCH/USD': {'id': 'BCCUSD', 'symbol': 'BCH/USD', 'base': 'BCH', 'quote': 'USD', 'baseId': 'BCC', 'quoteId': 'USD', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.00035}, 'cost': {'min':0.1} }},
                'BCH/EUR': {'id': 'BCCEUR', 'symbol': 'BCH/EUR', 'base': 'BCH', 'quote': 'EUR', 'baseId': 'BCC', 'quoteId': 'EUR', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.00035}, 'cost': {'min':0.1} }},
                'BCH/PLN': {'id': 'BCCPLN', 'symbol': 'BCH/PLN', 'base': 'BCH', 'quote': 'PLN', 'baseId': 'BCC', 'quoteId': 'PLN', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.00035}, 'cost': {'min':0.1} }},
                'BCH/BTC': {'id': 'BCCBTC', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC', 'baseId': 'BCC', 'quoteId': 'BTC', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.00035}, 'cost': {'min':0.00003} }},
                'BTG/USD': {'id': 'BTGUSD', 'symbol': 'BTG/USD', 'base': 'BTG', 'quote': 'USD', 'baseId': 'BTG', 'quoteId': 'USD', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.00045}, 'cost': {'min':0.1} }},
                'BTG/EUR': {'id': 'BTGEUR', 'symbol': 'BTG/EUR', 'base': 'BTG', 'quote': 'EUR', 'baseId': 'BTG', 'quoteId': 'EUR', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.00045}, 'cost': {'min':0.1} }},
                'BTG/PLN': {'id': 'BTGPLN', 'symbol': 'BTG/PLN', 'base': 'BTG', 'quote': 'PLN', 'baseId': 'BTG', 'quoteId': 'PLN', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.00045}, 'cost': {'min':0.1} }},
                'BTG/BTC': {'id': 'BTGBTC', 'symbol': 'BTG/BTC', 'base': 'BTG', 'quote': 'BTC', 'baseId': 'BTG', 'quoteId': 'BTC', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.00045}, 'cost': {'min':0.00003} }},
                'DASH/USD': {'id': 'DASHUSD', 'symbol': 'DASH/USD', 'base': 'DASH', 'quote': 'USD', 'baseId': 'DASH', 'quoteId': 'USD', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.00045}, 'cost': {'min':0.1} }},
                'DASH/EUR': {'id': 'DASHEUR', 'symbol': 'DASH/EUR', 'base': 'DASH', 'quote': 'EUR', 'baseId': 'DASH', 'quoteId': 'EUR', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.00045}, 'cost': {'min':0.1} }},
                'DASH/PLN': {'id': 'DASHPLN', 'symbol': 'DASH/PLN', 'base': 'DASH', 'quote': 'PLN', 'baseId': 'DASH', 'quoteId': 'PLN', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.00045}, 'cost': {'min':0.1} }},
                'DASH/BTC': {'id': 'DASHBTC', 'symbol': 'DASH/BTC', 'base': 'DASH', 'quote': 'BTC', 'baseId': 'DASH', 'quoteId': 'BTC', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.00045}, 'cost': {'min':0.00003} }},
                'GAME/USD': {'id': 'GAMEUSD', 'symbol': 'GAME/USD', 'base': 'GAME', 'quote': 'USD', 'baseId': 'GAME', 'quoteId': 'USD', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.05}, 'cost': {'min':0.1} }},
                'GAME/EUR': {'id': 'GAMEEUR', 'symbol': 'GAME/EUR', 'base': 'GAME', 'quote': 'EUR', 'baseId': 'GAME', 'quoteId': 'EUR', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.05}, 'cost': {'min':0.1} }},
                'GAME/PLN': {'id': 'GAMEPLN', 'symbol': 'GAME/PLN', 'base': 'GAME', 'quote': 'PLN', 'baseId': 'GAME', 'quoteId': 'PLN', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.05}, 'cost': {'min':0.1} }},
                'GAME/BTC': {'id': 'GAMEBTC', 'symbol': 'GAME/BTC', 'base': 'GAME', 'quote': 'BTC', 'baseId': 'GAME', 'quoteId': 'BTC', 'precision': {'price': 2, 'amount': 8 }, 'limits':{ 'amount': {'min':0.05}, 'cost': {'min':0.00003} }},
            },
            'fees': {
                'trading': {
                    'maker': 0.3 / 100,
                    'taker': 0.0043,
                },
                'funding': {
                    'withdraw': {
                        'BTC': 0.0009,
                        'LTC': 0.005,
                        'ETH': 0.00126,
                        'LSK': 0.2,
                        'BCH': 0.0006,
                        'GAME': 0.005,
                        'DASH': 0.001,
                        'BTG': 0.0008,
                        'PLN': 4,
                        'EUR': 1.5,
                    },
                },
            },
            'exceptions': {
                '400': ExchangeError,  # At least one parameter wasn't set
                '401': InvalidOrder,  # Invalid order type
                '402': InvalidOrder,  # No orders with specified currencies
                '403': InvalidOrder,  # Invalid payment currency name
                '404': InvalidOrder,  # Error. Wrong transaction type
                '405': InvalidOrder,  # Order with self id doesn't exist
                '406': InsufficientFunds,  # No enough money or crypto
                # code 407 not specified are not specified in their docs
                '408': InvalidOrder,  # Invalid currency name
                '501': AuthenticationError,  # Invalid public key
                '502': AuthenticationError,  # Invalid sign
                '503': InvalidNonce,  # Invalid moment parameter. Request time doesn't match current server time
                '504': ExchangeError,  # Invalid method
                '505': AuthenticationError,  # Key has no permission for self action
                '506': AuthenticationError,  # Account locked. Please contact with customer service
                # codes 507 and 508 are not specified in their docs
                '509': ExchangeError,  # The BIC/SWIFT is required for self currency
                '510': ExchangeError,  # Invalid market name
            },
        })

    def fetch_balance(self, params={}):
        response = self.privatePostInfo()
        if 'balances' in response:
            balance = response['balances']
            result = {'info': balance}
            codes = list(self.currencies.keys())
            for i in range(0, len(codes)):
                code = codes[i]
                currency = self.currencies[code]
                id = currency['id']
                account = self.account()
                if id in balance:
                    account['free'] = float(balance[id]['available'])
                    account['used'] = float(balance[id]['locked'])
                    account['total'] = self.sum(account['free'], account['used'])
                result[code] = account
            return self.parse_balance(result)
        raise ExchangeError(self.id + ' empty balance response ' + self.json(response))

    def fetch_order_book(self, symbol, limit=None, params={}):
        orderbook = self.publicGetIdOrderbook(self.extend({
            'id': self.market_id(symbol),
        }, params))
        return self.parse_order_book(orderbook)

    def fetch_ticker(self, symbol, params={}):
        ticker = self.publicGetIdTicker(self.extend({
            'id': self.market_id(symbol),
        }, params))
        timestamp = self.milliseconds()
        baseVolume = self.safe_float(ticker, 'volume')
        vwap = self.safe_float(ticker, 'vwap')
        quoteVolume = baseVolume * vwap
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_float(ticker, 'max'),
            'low': self.safe_float(ticker, 'min'),
            'bid': self.safe_float(ticker, 'bid'),
            'ask': self.safe_float(ticker, 'ask'),
            'vwap': vwap,
            'open': None,
            'close': None,
            'first': None,
            'last': self.safe_float(ticker, 'last'),
            'change': None,
            'percentage': None,
            'average': self.safe_float(ticker, 'average'),
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        }

    def parse_trade(self, trade, market):
        timestamp = trade['date'] * 1000
        return {
            'id': trade['tid'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': market['symbol'],
            'type': None,
            'side': trade['type'],
            'price': trade['price'],
            'amount': trade['amount'],
        }

    def parse_order(self, order, market):
        side = None
        type = None
        if 'type' in order:
            side = 'sell' if (order['type'] == 'ask') else 'buy'
            type = 'limit'
        symbol = market['symbol']
        timestamp = self.to_mili_timestamp(order['order_date'])
        amount = float(order['start_units'])
        remaining = float(order['units'])
        filled = amount - remaining
        price = float(order['start_price'])/float(order['start_units'])
        average = price
        cost = average * filled
        result = {
            'info': order,
            'id': str(order['order_id']),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'average': average,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'status': 'open',
            'fee': None,
        }
        return result

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        market = self.market(symbol)
        params['limit'] = 200
        params['sort'] = 'desc'
        response = self.publicGetIdTrades(self.extend({
            'id': market['id'],
        }, params))
        return self.parse_trades(response, market, since, limit)

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        if not symbol:
            raise ExchangeError(self.id + ' fetchOpenOrders requires a symbol parameter')
        self.load_markets()
        market = self.market(symbol)
        response = self.privatePostOrders(self.extend({
            'limit': limit
        }, params))

        if response:
            return self.parse_orders(response, market, since, limit)
        else:
            return []

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        if not symbol:
            raise ExchangeError(self.id + ' fetch_my_trades requires a symbol parameter')
        transactions = self.privatePostTransactions(self.extend({
            'market': symbol.replace('/','-')
        }, params))
        if not transactions:
            return []
        trades = []
        for transaction in transactions:
            timestamp = self.to_mili_timestamp(transaction['date'])
            trade = {
                'id': abs(hash(transaction['date'] + transaction['rate'] + transaction['amount'] + transaction['type'])),
                'info': transaction,
                'timestamp': timestamp,
                'datetime': self.iso8601(timestamp),
                'symbol': symbol,
                'type': 'limit',
                'side': 'sell' if transaction['type'] == 'ASK' else 'buy',
                'price': float(transaction['price']),
                'amount': float(transaction['amount']),
            }
            trades.append(trade)
        return trades

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        if type != 'limit':
            raise ExchangeError(self.id + ' allows limit orders only')
        market = self.market(symbol)
        response = self.privatePostTrade(self.extend({
            'type': side,
            'currency': market['baseId'],
            'amount': amount,
            'payment_currency': market['quoteId'],
            'rate': price,
        }, params))
        order_id = str(response['order_id'])
        timestamp = self.milliseconds()
        order = {
            'id': order_id,
            'info': response,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'average': price,
            'cost': 0,
            'amount': amount,
            'filled': 0,
            'remaining': amount,
            'status': 'open',
            'fee': None,
        }
        return order

    def cancel_order(self, id, symbol=None, params={}):
        return self.privatePostCancel({'id': id})

    def is_fiat(self, currency):
        fiatCurrencies = {
            'USD': True,
            'EUR': True,
            'PLN': True,
        }
        if currency in fiatCurrencies:
            return True
        return False

    def withdraw(self, code, amount, address, tag=None, params={}):
        self.load_markets()
        method = None
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
            'quantity': amount,
        }
        if self.is_fiat(code):
            method = 'privatePostWithdraw'
            # request['account'] = params['account']  # they demand an account number
            # request['express'] = params['express']  # whatever it means, they don't explain
            # request['bic'] = ''
        else:
            method = 'privatePostTransfer'
            request['address'] = address
        response = getattr(self, method)(self.extend(request, params))
        return {
            'info': response,
            'id': None,
        }

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api'][api]
        if api == 'public':
            url += '/' + self.implode_params(path, params) + '.json'
            url = self.url(url, params)
        else:
            self.check_required_credentials()
            body = self.urlencode(self.extend({
                'method': path,
                'moment': self.nonce(),
            }, params))
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'API-Key': self.apiKey,
                'API-Hash': self.hmac(self.encode(body), self.encode(self.secret), hashlib.sha512),
            }
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, httpCode, reason, url, method, headers, body):
        if not isinstance(body, basestring):
            return  # fallback to default error handler
        if len(body) < 2:
            return
        if (body[0] == '{') or (body[0] == '['):
            response = json.loads(body)
            if 'code' in response:
                #
                # bitbay returns the integer 'success': 1 key from their private API
                # or an integer 'code' value from 0 to 510 and an error message
                #
                #      {'success': 1, ...}
                #      {'code': 502, 'message': 'Invalid sign'}
                #      {'code': 0, 'message': 'offer funds not exceeding minimums'}
                #
                #      400 At least one parameter wasn't set
                #      401 Invalid order type
                #      402 No orders with specified currencies
                #      403 Invalid payment currency name
                #      404 Error. Wrong transaction type
                #      405 Order with self id doesn't exist
                #      406 No enough money or crypto
                #      408 Invalid currency name
                #      501 Invalid public key
                #      502 Invalid sign
                #      503 Invalid moment parameter. Request time doesn't match current server time
                #      504 Invalid method
                #      505 Key has no permission for self action
                #      506 Account locked. Please contact with customer service
                #      509 The BIC/SWIFT is required for self currency
                #      510 Invalid market name
                #
                code = response['code']  # always an integer
                feedback = self.id + ' ' + self.json(response)
                exceptions = self.exceptions
                if code in self.exceptions:
                    raise exceptions[code](feedback)
                else:
                    raise ExchangeError(feedback)

    def to_mili_timestamp(self, date):
        return ( time.mktime(dateutil.parser.parse(date).timetuple()) + dateutil.tz.tzlocal().utcoffset(datetime.datetime.now(dateutil.tz.tzlocal())).total_seconds() - 1 * 60 * 60 ) * 1000
